<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Listening Age Calculator</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 500;
        }

        input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .loading {
            text-align: center;
            margin-top: 20px;
            color: #667eea;
        }

        .progress {
            margin-top: 10px;
            font-size: 0.9em;
            color: #666;
        }

        .results {
            margin-top: 30px;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .listening-age {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .age-number {
            font-size: 4em;
            font-weight: bold;
            margin: 10px 0;
        }

        .stats {
            display: grid;
            gap: 15px;
        }

        .stat-card {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #333;
            font-size: 1.2em;
            font-weight: 600;
        }

        .decade-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .decade-name {
            width: 80px;
            font-weight: 500;
        }

        .bar-container {
            flex: 1;
            height: 24px;
            background: #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            margin: 0 10px;
        }

        .bar-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: width 0.5s ease;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ðŸŽµ Listening Age Calculator</h1>
        <p class="subtitle">Discover your musical era based on your Last.fm listening history</p>

        <div class="input-group">
            <label for="username">Last.fm Username</label>
            <input type="text" id="username" placeholder="Enter your Last.fm username">
        </div>

        <button id="calculate" onclick="calculateListeningAge()">Calculate My Listening Age</button>

        <div id="loading" class="loading" style="display: none;">
            <p>Analyzing your music taste...</p>
            <div class="progress" id="progress"></div>
        </div>

        <div id="error" class="error" style="display: none;"></div>
        <div id="results" class="results" style="display: none;"></div>
    </div>

<script>
const API_ENDPOINT = '/.netlify/functions/lastfm';

// Utility for updating progress text
function updateProgress(msg) {
    const p = document.getElementById('progress');
    if (p) p.textContent = msg;
}

// Generic backend fetch with solid error handling
async function fetchLastFM(params) {
    const query = new URLSearchParams(params).toString();
    const res = await fetch(`${API_ENDPOINT}?${query}`);

    if (!res.ok) {
        let body = null;
        try { body = await res.json(); } catch (_) {}
        throw new Error(body?.message || `Backend error: ${res.status}`);
    }

    return await res.json();
}

// MusicBrainz query helper
async function fetchMusicBrainz(artist, album) {
    // Encode query safely
    const q = encodeURIComponent(`artist:"${artist}" AND release:"${album}"`);
    const url = `https://musicbrainz.org/ws/2/release-group?query=${q}&fmt=json`;

    try {
        const res = await fetch(url, { headers: { 'User-Agent': 'ListeningAgeCalculator/1.0' } });
        const data = await res.json();
        if (!data['release-groups'] || data['release-groups'].length === 0) return null;

        // Pick earliest date from matches
        let best = null;
        for (const g of data['release-groups']) {
            const d = g['first-release-date'];
            if (d) {
                const year = parseInt(d.slice(0, 4), 10);
                if (!best || year < best) best = year;
            }
        }

        return best || null;
    } catch (err) {
        console.warn("MusicBrainz fail:", err.message);
        return null;
    }
}

// Try Last.fm track.getInfo as fallback
async function fetchTrackYear(artist, album, username) {
    try {
        const data = await fetchLastFM({
            method: "track.getInfo",
            artist,
            track: album,   // fallback guess for track name
            username
        });

        // Some tracks have wiki dates
        if (data?.track?.wiki?.published) {
            const year = new Date(data.track.wiki.published).getFullYear();
            if (!isNaN(year)) return year;
        }
    } catch (_) {}

    return null;
}

// Tag-based decade inference
function inferYearFromTags(tags = []) {
    const lower = tags.map(t => t.toLowerCase());

    const map = {
        '50s': 1950, '60s': 1960, '70s': 1970,
        '80s': 1980, '90s': 1990,
        '00s': 2000, '2000s': 2000,
        '10s': 2010, '2010s': 2010,
        '20s': 2020, '2020s': 2020
    };

    for (const tag of lower) {
        for (const key in map) {
            if (tag.includes(key)) return map[key];
        }
    }

    return null;
}

// Main album metadata resolver (4-layer fallback)
async function resolveAlbumYear(album, username, index, total) {
    const artist = album.artist.name;
    const name = album.name;

    updateProgress(`Resolving metadata ${index}/${total}: ${artist} â€” ${name}`);

    // 1. Last.fm album.getinfo
    try {
        const data = await fetchLastFM({
            method: "album.getinfo",
            artist,
            album: name,
            username
        });

        if (data?.album?.wiki?.published) {
            const y = new Date(data.album.wiki.published).getFullYear();
            if (!isNaN(y)) return y;
        }

        // Try infer from top tags
        if (data?.album?.tags?.tag) {
            const tagYear = inferYearFromTags(data.album.tags.tag.map(t => t.name));
            if (tagYear) return tagYear;
        }
    } catch (_) {}

    // 2. Last.fm track.getinfo fallback
    const trackYear = await fetchTrackYear(artist, name, username);
    if (trackYear) return trackYear;

    // 3. MusicBrainz fallback
    const mbYear = await fetchMusicBrainz(artist, name);
    if (mbYear) return mbYear;

    // 4. No metadata at all
    return null;
}

// Fetch top albums (100)
async function fetchTopAlbums(username) {
    const data = await fetchLastFM({
        method: "user.gettopalbums",
        user: username,
        limit: 100,
        period: "overall"
    });

    if (data.error) throw new Error(data.message);
    return data.topalbums?.album || [];
}

async function fetchAlbumDates(albums, username) {
    const out = [];
    const total = Math.min(albums.length, 100);

    for (let i = 0; i < total; i++) {
        const album = albums[i];
        const year = await resolveAlbumYear(album, username, i + 1, total);

        if (year && year >= 1950 && year <= new Date().getFullYear()) {
            out.push({
                name: album.name,
                artist: album.artist.name,
                playcount: parseInt(album.playcount, 10) || 0,
                year
            });
        }

        // polite rate limit for API
        await new Promise(res => setTimeout(res, 100));
    }

    return out;
}

// HYBRID SCORE: mean + median + decade weighting
function analyzeListeningAge(albums) {
    if (albums.length === 0) throw new Error("No usable album metadata.");

    const years = albums.map(a => a.year).sort((a, b) => a - b);

    const mean = years.reduce((a, b) => a + b, 0) / years.length;
    const median = years[Math.floor(years.length / 2)];

    // Build decade histogram
    const decadeCounts = {};
    years.forEach(y => {
        const d = Math.floor(y / 10) * 10;
        decadeCounts[d] = (decadeCounts[d] || 0) + 1;
    });

    // Pick the highest-density decade
    let bestDecade = null;
    let maxCount = 0;
    for (const d in decadeCounts) {
        if (decadeCounts[d] > maxCount) {
            maxCount = decadeCounts[d];
            bestDecade = parseInt(d, 10);
        }
    }

    // Final predicted decade as weighted combo
    const predictedDecade = Math.round(
        (median * 0.4 + mean * 0.4 + (bestDecade + 5) * 0.2)
    );

    const current = new Date().getFullYear();
    const listeningAge = Math.max(0, current - predictedDecade);

    return {
        listeningAge,
        dominantDecade: Math.floor(predictedDecade / 10) * 10,
        averageYear: Math.round(mean),
        totalAlbums: albums.length,
        decadeDistribution: decadeCounts
    };
}

// Display UI results
function displayResults(a) {
    const resultsDiv = document.getElementById('results');

    const decades = Object.keys(a.decadeDistribution).sort();
    const max = Math.max(...Object.values(a.decadeDistribution));

    let bars = '';
    decades.forEach(decade => {
        const count = a.decadeDistribution[decade];
        const pct = (count / max) * 100;
        const crown = parseInt(decade) === a.dominantDecade ? 'ðŸ‘‘' : '';

        bars += `
            <div class="decade-bar">
                <div class="decade-name">${decade}s</div>
                <div class="bar-container">
                    <div class="bar-fill" style="width:${pct}%"></div>
                </div>
                <div style="width:50px;text-align:right">${count} ${crown}</div>
            </div>
        `;
    });

    resultsDiv.innerHTML = `
        <div class="listening-age">
            <div>Your Listening Age</div>
            <div class="age-number">${a.listeningAge}</div>
            <div>You listen like someone from the ${a.dominantDecade}s!</div>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-label">Dominant Decade</div>
                <div class="stat-value">${a.dominantDecade}s</div>
            </div>

            <div class="stat-card">
                <div class="stat-label">Albums Analyzed</div>
                <div class="stat-value">${a.totalAlbums}</div>
            </div>

            <div class="stat-card">
                <div class="stat-label">Average Release Year</div>
                <div class="stat-value">${a.averageYear}</div>
            </div>

            <div class="stat-card">
                <div class="stat-label">Decade Distribution</div>
                ${bars}
            </div>
        </div>
    `;

    resultsDiv.style.display = 'block';
}

function showError(msg) {
    const e = document.getElementById('error');
    e.textContent = msg;
    e.style.display = 'block';
}

// Main entry
document.getElementById('username').addEventListener('keypress', e => {
    if (e.key === 'Enter') calculateListeningAge();
});

async function calculateListeningAge() {
    const username = document.getElementById('username').value.trim();

    if (!username) {
        showError('Please enter your Last.fm username');
        return;
    }

    document.getElementById('calculate').disabled = true;
    document.getElementById('loading').style.display = 'block';
    document.getElementById('error').style.display = 'none';
    document.getElementById('results').style.display = 'none';

    try {
        updateProgress('Fetching top albums...');
        const albums = await fetchTopAlbums(username);

        updateProgress('Resolving album metadata...');
        const dated = await fetchAlbumDates(albums, username);

        updateProgress('Crunching numbers...');
        const analysis = analyzeListeningAge(dated);

        displayResults(analysis);
    } catch (err) {
        showError(err.message);
    } finally {
        document.getElementById('calculate').disabled = false;
        document.getElementById('loading').style.display = 'none';
        updateProgress('');
    }
}
</script>


</body>
</html>
